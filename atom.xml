<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只研究僧er</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-10T07:41:35.141Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>刘恒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode45.跳跃游戏 II</title>
    <link href="http://example.com/2023/03/10/leetcode45/"/>
    <id>http://example.com/2023/03/10/leetcode45/</id>
    <published>2023-03-10T07:11:01.000Z</published>
    <updated>2023-03-10T07:41:35.141Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j + nums[j] &lt; i) j ++;</span><br><span class="line">            f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元素 &lt;code&gt;nums[i]&lt;/code&gt; 表示从索引 &lt;code&gt;i&lt;/code&gt; 向前跳转的最大长度。换句话说，如果你在 &lt;code&gt;nums[i]&lt;/code&gt; 处，你可以跳转到任意 &lt;code&gt;nums[i + j]&lt;/code&gt; 处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= j &amp;lt;= nums[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;i + j &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回到达 &lt;code&gt;nums[n - 1]&lt;/code&gt; 的最小跳跃次数。生成的测试用例可以到达 &lt;code&gt;nums[n - 1]&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode44.通配符匹配</title>
    <link href="http://example.com/2023/03/10/leetcode44/"/>
    <id>http://example.com/2023/03/10/leetcode44/</id>
    <published>2023-03-10T07:10:58.000Z</published>
    <updated>2023-03-10T07:36:14.908Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;?&#x27; 可以匹配任何单个字符。</span><br><span class="line">&#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong><br>$$<br>\<br>题解1：和第十题类似，双字符串匹配问题，可以用动态规划来做。\<br>状态表示：\<br>    dp[i][j]代表s的前i个字符和p的前j个字符是否匹配。\<br>    状态初始化：dp[0][0] &#x3D; true，对于1 &lt;&#x3D; i &lt;&#x3D; m如果p[i - 1] &#x3D; ‘<em>‘ &amp;&amp; dp[0][i - 1]那么dp[0][i] &#x3D; true，这对应着p以</em>*<em>as开头的字符串，因为</em>可以代表0个字符，所以可以往后匹配。\</p><p>状态转移：\<br>    s[i - 1] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; ‘?’，这时候是精准匹配，所以取决于s的前i - 1个字符和p的前j - 1个字符是否匹配。dp[i][j] &#x3D; dp[i - 1][j - 1];\<br>    p[j - 1] &#x3D;&#x3D; ‘<em>‘，这个时候</em>可以代表空串或者任意多个字符。\<br>    如果是空串，那么dp[i][j] &#x3D; dp[i][j - 1]\<br>    如果不是空串，那么dp[i][j] &#x3D; dp[i - 1][j]。这是因为<em>代表了任意多个字符，如果能匹配前i - 1个字符，那么就在</em>代表的字符串后面加上s[i]，就可以匹配前i个字符啦。\<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板题：高精度乘法</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s, p = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    f[i][j] = i &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || i &amp;&amp; f[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/wildcard-matching/">44. 通配符匹配 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个字符串 (&lt;code&gt;s&lt;/code&gt;) 和一个字符模式 (&lt;code&gt;p&lt;/code&gt;) ，实现一个支持 &lt;code&gt;&amp;#39;?&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt; 的通配符匹配。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x27;?&amp;#x27; 可以匹配任何单个字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x27;*&amp;#x27; 可以匹配任意字符串（包括空字符串）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;两个字符串&lt;strong&gt;完全匹配&lt;/strong&gt;才算匹配成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 可能为空，且只包含从 &lt;code&gt;a-z&lt;/code&gt; 的小写字母。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 可能为空，且只包含从 &lt;code&gt;a-z&lt;/code&gt; 的小写字母，以及字符 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode43.字符串相乘</title>
    <link href="http://example.com/2023/03/10/leetcode43/"/>
    <id>http://example.com/2023/03/10/leetcode43/</id>
    <published>2023-03-10T07:10:56.000Z</published>
    <updated>2023-03-10T07:26:32.902Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板题：高精度乘法</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="comment">// 倒着存，方便计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt; m;j ++)</span><br><span class="line">                <span class="comment">// i + j错位相加</span></span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line"><span class="comment">// t为进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>;i &lt; C.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  去除前导0</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !C[k]) k --;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) res += C[k --] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定两个以字符串形式表示的非负整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt;，返回 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;不能使用任何内置的 BigInteger 库或直接将输入转换为整数。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="高精度乘法" scheme="http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42.接雨水</title>
    <link href="http://example.com/2023/03/10/leetcode42/"/>
    <id>http://example.com/2023/03/10/leetcode42/</id>
    <published>2023-03-10T07:10:53.000Z</published>
    <updated>2023-03-10T07:21:40.871Z</updated>
    
    <content type="html"><![CDATA[<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单调栈：获取当前位置左右比他大的</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; skt;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!skt.<span class="built_in">empty</span>() &amp;&amp; height[skt.<span class="built_in">top</span>()] &lt; height[i]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = skt.<span class="built_in">top</span>(); <span class="comment">// i 为t右边第一个比他大的</span></span><br><span class="line">                skt.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 此时栈顶为左边第一个比他大的</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (skt.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                res += (i - skt.<span class="built_in">top</span>() - <span class="number">1</span>) * (<span class="built_in">min</span>(height[i], height[skt.<span class="built_in">top</span>()]) - height[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            skt.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="单调栈" scheme="http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode41.缺失的第一个正数</title>
    <link href="http://example.com/2023/03/10/leetcode41/"/>
    <id>http://example.com/2023/03/10/leetcode41/</id>
    <published>2023-03-10T07:10:09.000Z</published>
    <updated>2023-03-10T07:18:57.898Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心思想：把数字放到该放的位置</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">            <span class="keyword">if</span> (x != INT_MIN) x --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; n) &amp;&amp; nums[i] != i &amp;&amp; nums[i] != nums[nums[i]])</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;p&gt;请你实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 并且只使用常数级别额外空间的解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="基数排序" scheme="http://example.com/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode40.组合总和 II</title>
    <link href="http://example.com/2023/03/08/leetcode40/"/>
    <id>http://example.com/2023/03/08/leetcode40/</id>
    <published>2023-03-08T02:22:11.000Z</published>
    <updated>2023-03-08T02:49:32.007Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DFS经典问题---组合</span><br><span class="line">搜索顺序：一个数一个数搜</span><br><span class="line">剪枝：</span><br><span class="line">- (i &gt; u &amp;&amp; candidates[i] == candidates[i - 1]) continue; // 不能包含重复解集</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> u, <span class="type">int</span> target, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u;i &lt; candidates.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; u &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 不能包含重复解集</span></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, target, sum);  <span class="comment">// 不可以重复使用所以u = i + 1</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个候选人编号的集合 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用 &lt;strong&gt;一次&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;解集不能包含重复的组合。 &lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode39.组合总和</title>
    <link href="http://example.com/2023/03/08/leetcode39/"/>
    <id>http://example.com/2023/03/08/leetcode39/</id>
    <published>2023-03-08T02:22:08.000Z</published>
    <updated>2023-03-08T02:48:37.510Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS经典问题---组合</span><br><span class="line">搜索顺序：一个数一个数搜</span><br><span class="line">剪枝：</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> u, <span class="type">int</span> target, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u;i &lt; candidates.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i, target, sum);  <span class="comment">// 可以重复使用所以u = i</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 &lt;strong&gt;无重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标整数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中可以使数字和为目标数 &lt;code&gt;target&lt;/code&gt; 的 所有 &lt;strong&gt;不同组合&lt;/strong&gt; ，并以列表形式返回。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回这些组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的 &lt;strong&gt;同一个&lt;/strong&gt; 数字可以 &lt;strong&gt;无限制重复被选取&lt;/strong&gt; 。如果至少一个数字的被选数量不同，则两种组合是不同的。 &lt;/p&gt;
&lt;p&gt;对于给定的输入，保证和为 &lt;code&gt;target&lt;/code&gt; 的不同组合数少于 &lt;code&gt;150&lt;/code&gt; 个。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode38.外观数列</title>
    <link href="http://example.com/2023/03/08/leetcode38/"/>
    <id>http://example.com/2023/03/08/leetcode38/</id>
    <published>2023-03-08T02:22:05.000Z</published>
    <updated>2023-03-08T02:37:41.186Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li></ul><p>前五项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure><p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br><span class="line"></span><br><span class="line">输入：n = 4</span><br><span class="line">输出：&quot;1211&quot;</span><br><span class="line">解释：</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = 读 &quot;1&quot; = 一 个 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = 读 &quot;11&quot; = 二 个 1 = &quot;21&quot;</span><br><span class="line">countAndSay(4) = 读 &quot;21&quot; = 一 个 2 + 一 个 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n : 为描述次数</span><br><span class="line">初始为&quot;1&quot;,再描述n - 1次即可</span><br><span class="line">对于每次描述，依靠双指针来实现</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">            <span class="comment">// 描述次数</span></span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">                <span class="type">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == s[j]) k ++; <span class="comment">// 统计相同字符出现次数</span></span><br><span class="line">                t += <span class="built_in">to_string</span>(k - j) + s[j];</span><br><span class="line">                j = k; <span class="comment">//从下一个不同的字符继续</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/count-and-say/">38. 外观数列 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个正整数 &lt;code&gt;n&lt;/code&gt; ，输出外观数列的第 &lt;code&gt;n&lt;/code&gt; 项。&lt;/p&gt;
&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;
&lt;p&gt;你可以将其视作是由递归公式定义的数字字符串序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;countAndSay(1) = &amp;quot;1&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;countAndSay(n)&lt;/code&gt; 是对 &lt;code&gt;countAndSay(n-1)&lt;/code&gt; 的描述，然后转换成另一个数字字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前五项如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.     11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.     21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.     1211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.     111221&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一项是数字 1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &amp;quot;11&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &amp;quot;21&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &amp;quot;1211&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &amp;quot;111221&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要 &lt;strong&gt;描述&lt;/strong&gt; 一个数字字符串，首先要将字符串分割为 &lt;strong&gt;最小&lt;/strong&gt; 数量的组，每个组都由连续的最多 &lt;strong&gt;相同字符&lt;/strong&gt; 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode37.解数独</title>
    <link href="http://example.com/2023/03/08/leetcode37/"/>
    <id>http://example.com/2023/03/08/leetcode37/</id>
    <published>2023-03-08T02:22:02.000Z</published>
    <updated>2023-03-08T02:31:10.216Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p></li></ul><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 搜索顺序： 按行搜索每个单元</span><br><span class="line">- 剪枝条件： 行、列，单元格不重复出现</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> row[<span class="number">9</span>][<span class="number">9</span>], col[<span class="number">9</span>][<span class="number">9</span>], cell[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]; <span class="comment">// 记录行、列和单元格出现的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">9</span>) x ++, y = <span class="number">0</span>; <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 搜索完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="built_in">dfs</span>(board, x, y + <span class="number">1</span>); <span class="comment">//单元为空才搜索</span></span><br><span class="line">        <span class="comment">// 枚举数字，看单元可以填充那个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i]) &#123;</span><br><span class="line">                row[x][i] = col[y][i] = cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                board[x][y] = <span class="string">&#x27;1&#x27;</span> + i;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, x, y + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                row[x][i] = col[y][i] = cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">                board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="literal">false</span>, <span class="keyword">sizeof</span> row);</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">        <span class="built_in">memset</span>(cell, <span class="literal">false</span>, <span class="keyword">sizeof</span> cell);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> t = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i][t] = col[j][t] = cell[i / <span class="number">3</span>][j / <span class="number">3</span>][t] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需 &lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数独部分空格内已填入了数字，空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode36.有效的数独</title>
    <link href="http://example.com/2023/03/08/leetcode36/"/>
    <id>http://example.com/2023/03/08/leetcode36/</id>
    <published>2023-03-08T02:21:56.000Z</published>
    <updated>2023-03-08T02:26:28.295Z</updated>
    
    <content type="html"><![CDATA[<p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>空白格用 <code>&#39;.&#39;</code> 表示。</li></ul><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依次按行、列，单元格枚举</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> st[<span class="number">9</span>];</span><br><span class="line"><span class="comment">// 按行枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> t = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st[t] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 按列枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> t = board[j][i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st[t] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 按单元格枚举</span></span><br><span class="line">        <span class="comment">// 通过左上角坐标枚举单元格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i +=<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>;x &lt; <span class="number">3</span>;x ++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>;y &lt; <span class="number">3</span>;y ++)</span><br><span class="line">                    <span class="keyword">if</span> (board[i + x][j + y] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> t = board[i + x][j + y] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span> (st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        st[t] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/valid-sudoku/">36. 有效的数独 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;请你判断一个 &lt;code&gt;9 x 9&lt;/code&gt; 的数独是否有效。只需要 &lt;strong&gt;根据以下规则&lt;/strong&gt; ，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;/li&gt;
&lt;li&gt;空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="枚举" scheme="http://example.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode35.搜索插入位置</title>
    <link href="http://example.com/2023/03/07/leetcode35/"/>
    <id>http://example.com/2023/03/07/leetcode35/</id>
    <published>2023-03-07T04:18:21.000Z</published>
    <updated>2023-03-07T04:42:34.701Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分，注意边界</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target &gt; nums.<span class="built_in">back</span>() ? nums.<span class="built_in">size</span>() : l; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode34.在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://example.com/2023/03/07/leetcode34/"/>
    <id>http://example.com/2023/03/07/leetcode34/</id>
    <published>2023-03-07T04:18:18.000Z</published>
    <updated>2023-03-07T04:43:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两次二分：</span><br><span class="line">- 从左到右，找右边界</span><br><span class="line">- 从右到左，找左边界 </span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == target)</span><br><span class="line">            res[<span class="number">1</span>] = l;</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == target)</span><br><span class="line">            res[<span class="number">0</span>] = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target &gt; nums.<span class="built_in">back</span>() ? nums.<span class="built_in">size</span>() : l; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode33.搜索旋转排序数组</title>
    <link href="http://example.com/2023/03/07/leetcode33/"/>
    <id>http://example.com/2023/03/07/leetcode33/</id>
    <published>2023-03-07T04:18:15.000Z</published>
    <updated>2023-03-07T04:39:51.380Z</updated>
    
    <content type="html"><![CDATA[<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两步二分：</span><br><span class="line"> - 搜索旋转点</span><br><span class="line"> - 搜索target</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> l = r + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (nums[r] == target) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整数数组 &lt;code&gt;nums&lt;/code&gt; 按升序排列，数组中的值 &lt;strong&gt;互不相同&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，&lt;code&gt;nums&lt;/code&gt; 在预先未知的某个下标 &lt;code&gt;k&lt;/code&gt;（&lt;code&gt;0 &amp;lt;= k &amp;lt; nums.length&lt;/code&gt;）上进行了 &lt;strong&gt;旋转&lt;/strong&gt;，使数组变为 &lt;code&gt;[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]&lt;/code&gt;（下标 &lt;strong&gt;从 0 开始&lt;/strong&gt; 计数）。例如， &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 在下标 &lt;code&gt;3&lt;/code&gt; 处经旋转后可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你 &lt;strong&gt;旋转后&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt; ，如果 &lt;code&gt;nums&lt;/code&gt; 中存在这个目标值 &lt;code&gt;target&lt;/code&gt; ，则返回它的下标，否则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你必须设计一个时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32.最长有效括号</title>
    <link href="http://example.com/2023/03/07/leetcode32/"/>
    <id>http://example.com/2023/03/07/leetcode32/</id>
    <published>2023-03-07T04:18:12.000Z</published>
    <updated>2023-03-07T04:27:52.814Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态表示：</span><br><span class="line">设 f(i)为以i为结尾的最长合法子串。</span><br><span class="line">初始时，f(0)=0。</span><br><span class="line">状态计算：</span><br><span class="line">    转移时，我们仅考虑当前字符是 ) 的时候。如果上一个字符是 (，即 ...() 结尾的情况，则 f(i)=f(i−1)+2。如果上一个字符是 )，即 ...)) 的情况，则我们通过上一个字符的动规结果，判断是否能匹配末尾的 )。判断 s[i - f(i - 1) - 1] 是 (，即 ...((合法))，则可以转移 f(i)=f(i−1)+2+f(i−f(i−1)−2)。最终答案为动规数组中的最大值。</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) f[i] = f[i - <span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> f[i] = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - f[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - f[i - <span class="number">1</span>] - <span class="number">1</span>] ==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="keyword">if</span> (i - f[i - <span class="number">1</span>]- <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                            f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span> + f[i - f[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                        <span class="keyword">else</span> </span><br><span class="line">                            f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个只包含 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode31.下一个排列</title>
    <link href="http://example.com/2023/03/07/leetcode31/"/>
    <id>http://example.com/2023/03/07/leetcode31/</id>
    <published>2023-03-07T04:17:49.000Z</published>
    <updated>2023-03-07T04:23:25.429Z</updated>
    
    <content type="html"><![CDATA[<p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思维题：</span><br><span class="line">- 从后往前枚举，找到第一个出现降序的位置记作k;</span><br><span class="line">- 从k出发往后枚举找到比他大的最小的数</span><br><span class="line">- 交换位置</span><br><span class="line">- 后k个数降序排列</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k --;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = k;</span><br><span class="line">            <span class="keyword">while</span> (t &lt; n &amp;&amp; nums[t] &gt; nums[k - <span class="number">1</span>]) t ++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[t - <span class="number">1</span>], nums[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整数数组的一个 &lt;strong&gt;排列&lt;/strong&gt; 就是将其所有成员以序列或线性顺序排列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;arr = [1,2,3]&lt;/code&gt; ，以下这些都可以视作 &lt;code&gt;arr&lt;/code&gt; 的排列：&lt;code&gt;[1,2,3]&lt;/code&gt;、&lt;code&gt;[1,3,2]&lt;/code&gt;、&lt;code&gt;[3,1,2]&lt;/code&gt;、&lt;code&gt;[2,3,1]&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整数数组的 &lt;strong&gt;下一个排列&lt;/strong&gt; 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 &lt;strong&gt;下一个排列&lt;/strong&gt; 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;arr = [1,2,3]&lt;/code&gt; 的下一个排列是 &lt;code&gt;[1,3,2]&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;类似地，&lt;code&gt;arr = [2,3,1]&lt;/code&gt; 的下一个排列是 &lt;code&gt;[3,1,2]&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;而 &lt;code&gt;arr = [3,2,1]&lt;/code&gt; 的下一个排列是 &lt;code&gt;[1,2,3]&lt;/code&gt; ，因为 &lt;code&gt;[3,2,1]&lt;/code&gt; 不存在一个字典序更大的排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出 &lt;code&gt;nums&lt;/code&gt; 的下一个排列。&lt;/p&gt;
&lt;p&gt;必须**&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地 &lt;/a&gt;**修改，只允许使用额外常数空间。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="思维题" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode30.串联所有单词的子串</title>
    <link href="http://example.com/2023/03/06/leetcode30/"/>
    <id>http://example.com/2023/03/06/leetcode30/</id>
    <published>2023-03-06T02:36:33.000Z</published>
    <updated>2023-03-06T05:20:45.062Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p> <code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联字串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。</span><br><span class="line">子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class="line">子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br><span class="line">输出顺序无关紧要。返回 [9,0] 也是可以的。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一种比较简单的暴力做法是枚举s的每个位置，然后考虑以该位置为起点是否存在一个由words里所有单词拼接而成的字符串，由于每个word长度相同，可以利用哈希表，一个单词一个单词的来枚举，看最后是否用完了words里的单词并且中间不存在不合法的单词。这样的复杂度为O(n∗w∗m)，n为字符串s的长度，w是单词的长度，m是单词列表words的长度。不过这个做法会超时。</span><br><span class="line"></span><br><span class="line">下面我们考虑怎么优化这个做法，因为有单词长度都相同这个限制，问题可以转化成将字符串s切成每段长度为w的序列，那么不同的序列最多有多少个（长度不足w的抛弃）？答案是w个，从起点0,1,2,...,w-1开始最多可以有w个不同的单词序列，从w开始的序列和从0开始的是等价的。</span><br><span class="line"></span><br><span class="line">所以我们就可以枚举每个序列，对于每个序列我们可以用双指针来搜索包含words所有单词的连续序列。这里是以单词为单位进行双指针移动，双指针的思路类似于LeetCode 3. Longest Substring Without Repeating Characters ， 我们每次将窗口右端的单词加入哈希表，如果它的个数大于words中的个数，当前序列肯定不合法，我们不断地移动左端点使得窗口再次合法，当窗口长度为m时说明我们找到了一个答案。</span><br><span class="line">共有w个序列，每次枚举序列需要O(n)的复杂度，总时间复杂度为O(n∗w)，比暴力做法优化掉了单词列表长度m.</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = words.<span class="built_in">size</span>(), w = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; word : words)</span><br><span class="line">            cnt[word] ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; w;i ++) &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; window;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i;j + w &lt;= n;j += w) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i + m * w) &#123;</span><br><span class="line">                    string word = s.<span class="built_in">substr</span>(j - m * w, w);</span><br><span class="line">                    window[word] --;</span><br><span class="line">                    <span class="keyword">if</span> (window[word] &lt; cnt[word]) num --;</span><br><span class="line">                &#125;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, w);</span><br><span class="line">                window[word] ++;</span><br><span class="line">                <span class="keyword">if</span> (window[word] &lt;= cnt[word]) num ++;</span><br><span class="line">                <span class="keyword">if</span> (num == m) res.<span class="built_in">push_back</span>(j - (m - <span class="number">1</span>) * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串数组 &lt;code&gt;words&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt; &lt;code&gt;words&lt;/code&gt; 中所有字符串 &lt;strong&gt;长度相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;s&lt;/code&gt; 中的 &lt;strong&gt;串联子串&lt;/strong&gt; 是指一个包含 &lt;code&gt;words&lt;/code&gt; 中所有字符串以任意顺序排列连接起来的子串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，如果 &lt;code&gt;words = [&amp;quot;ab&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ef&amp;quot;]&lt;/code&gt;， 那么 &lt;code&gt;&amp;quot;abcdef&amp;quot;&lt;/code&gt;， &lt;code&gt;&amp;quot;abefcd&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;cdabef&amp;quot;&lt;/code&gt;， &lt;code&gt;&amp;quot;cdefab&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;efabcd&amp;quot;&lt;/code&gt;， 和 &lt;code&gt;&amp;quot;efcdab&amp;quot;&lt;/code&gt; 都是串联子串。 &lt;code&gt;&amp;quot;acdbef&amp;quot;&lt;/code&gt; 不是串联子串，因为他不是任何 &lt;code&gt;words&lt;/code&gt; 排列的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回所有串联字串在 &lt;code&gt;s&lt;/code&gt; 中的开始索引。你可以以 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>leetcode29.两数相除</title>
    <link href="http://example.com/2023/03/06/leetcode29/"/>
    <id>http://example.com/2023/03/06/leetcode29/</id>
    <published>2023-03-06T02:36:30.000Z</published>
    <updated>2023-03-06T03:09:12.566Z</updated>
    
    <content type="html"><![CDATA[<p>给你两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。</p><p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的 <strong>商</strong> 。</p><p><strong>注意：</strong>假设我们的环境只能存储 <strong>32 位</strong> 有符号整数，其数值范围是 <code>[−231, 231 − 1]</code> 。本题中，如果商 <strong>严格大于</strong> <code>231 − 1</code> ，则返回 <code>231 − 1</code> ；如果商 <strong>严格小于</strong> <code>-231</code> ，则返回 <code>-231</code> 。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10/3 = 3.33333.. ，向零截断后得到 3 。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义商为n,则n可以通过x与y的减法得到</span><br><span class="line">while (x) &#123;</span><br><span class="line">x -= y;</span><br><span class="line">n ++;</span><br><span class="line">&#125;</span><br><span class="line">由于数据范围的影响，-2^31 &lt;= dividend, divisor &lt;= 2^31 - 1，最坏情况下需要2^31 - 1减法操作会超时</span><br><span class="line">因此，需要优化</span><br><span class="line">x 可以表示为x = 2 ^ 0 * y + 2 ^ 1 * y + …… + 2 ^ 31 - 1 * y;</span><br><span class="line">因此只需要考虑每一位是否需要，常数时间复杂度</span><br><span class="line">为了方便起见，可以从大到小考虑</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        vector&lt;LL&gt; exp;<span class="comment">//指数项</span></span><br><span class="line">        <span class="type">bool</span> is_minus = <span class="literal">false</span>;<span class="comment">//负号</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> || x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) is_minus = <span class="literal">true</span>;<span class="comment">//异号相除的结果为负</span></span><br><span class="line">        <span class="comment">//预处理2*b^i</span></span><br><span class="line">        LL a = <span class="built_in">abs</span>((LL)x), b = <span class="built_in">abs</span>((LL)y);<span class="comment">//先直接用正数算，到时候结果加上负号就可以</span></span><br><span class="line">        <span class="keyword">for</span> (LL i = b; i &lt;= a; i = i + i) exp.<span class="built_in">push_back</span>(i);<span class="comment">//i从除数开始，只要i还小于被除数a，就倍增i，然后将指数项插入到exp数组里</span></span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;<span class="comment">//存答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = exp.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//从大到小开始减</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt;= exp[i]) &#123;<span class="comment">//还可以做减法</span></span><br><span class="line">                a -= exp[i];<span class="comment">//减去对应的数</span></span><br><span class="line">                res += <span class="number">1ll</span> &lt;&lt; i;<span class="comment">//左移一位，相当于乘以2，因为是基于倍增的思想，所以能减多少次，就左移多少次即可得到结果</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_minus) res = -res;<span class="comment">//负号的话就直接取反</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) res = INT_MAX;<span class="comment">//处理溢出的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/divide-two-integers/">29. 两数相除 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你两个整数，被除数 &lt;code&gt;dividend&lt;/code&gt; 和除数 &lt;code&gt;divisor&lt;/code&gt;。将两数相除，要求 &lt;strong&gt;不使用&lt;/strong&gt; 乘法、除法和取余运算。&lt;/p&gt;
&lt;p&gt;整数除法应该向零截断，也就是截去（&lt;code&gt;truncate&lt;/code&gt;）其小数部分。例如，&lt;code&gt;8.345&lt;/code&gt; 将被截断为 &lt;code&gt;8&lt;/code&gt; ，&lt;code&gt;-2.7335&lt;/code&gt; 将被截断至 &lt;code&gt;-2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回被除数 &lt;code&gt;dividend&lt;/code&gt; 除以除数 &lt;code&gt;divisor&lt;/code&gt; 得到的 &lt;strong&gt;商&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;假设我们的环境只能存储 &lt;strong&gt;32 位&lt;/strong&gt; 有符号整数，其数值范围是 &lt;code&gt;[−231, 231 − 1]&lt;/code&gt; 。本题中，如果商 &lt;strong&gt;严格大于&lt;/strong&gt; &lt;code&gt;231 − 1&lt;/code&gt; ，则返回 &lt;code&gt;231 − 1&lt;/code&gt; ；如果商 &lt;strong&gt;严格小于&lt;/strong&gt; &lt;code&gt;-231&lt;/code&gt; ，则返回 &lt;code&gt;-231&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode28.找出字符串中第一个匹配项的下标</title>
    <link href="http://example.com/2023/03/06/leetcode28/"/>
    <id>http://example.com/2023/03/06/leetcode28/</id>
    <published>2023-03-06T02:36:26.000Z</published>
    <updated>2023-03-06T02:48:56.716Z</updated>
    
    <content type="html"><![CDATA[<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KMP算法</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s, p = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ne</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 求解next数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">            ne[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 匹配过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;i &lt;= m;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                res = i - n;</span><br><span class="line">                j = ne[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你两个字符串 &lt;code&gt;haystack&lt;/code&gt; 和 &lt;code&gt;needle&lt;/code&gt; ，请你在 &lt;code&gt;haystack&lt;/code&gt; 字符串中找出 &lt;code&gt;needle&lt;/code&gt; 字符串的第一个匹配项的下标（下标从 0 开始）。如果 &lt;code&gt;needle&lt;/code&gt; 不是 &lt;code&gt;haystack&lt;/code&gt; 的一部分，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode27.移除元素</title>
    <link href="http://example.com/2023/03/06/leetcode27/"/>
    <id>http://example.com/2023/03/06/leetcode27/</id>
    <published>2023-03-06T02:36:22.000Z</published>
    <updated>2023-03-06T02:45:25.669Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快慢指针：比较fast和val对应数值是否相等，不相等则将fast对应值付给slow</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow ++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt; 移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素，并返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须仅使用 &lt;code&gt;O(1)&lt;/code&gt; 额外空间并 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地 &lt;/a&gt;修改输入数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么返回数值是整数，但输出的答案是数组呢?&lt;/p&gt;
&lt;p&gt;请注意，输入数组是以&lt;strong&gt;「引用」&lt;/strong&gt;方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。&lt;/p&gt;
&lt;p&gt;你可以想象内部操作如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int len = removeElement(nums, val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在函数里修改输入数组对于调用者是可见的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (int i = 0; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(nums[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26.删除有序数组中的重复项</title>
    <link href="http://example.com/2023/03/06/leetcode26/"/>
    <id>http://example.com/2023/03/06/leetcode26/</id>
    <published>2023-03-06T02:35:53.000Z</published>
    <updated>2023-03-06T02:42:46.919Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。</p><p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p><p>不要使用额外的空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">升序数组重复项一定相邻</span><br><span class="line"></span><br><span class="line">快慢指针：比较fast和slow对应数值是否相等，不相等则将fast对应值付给slow</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] != nums[fast]) &#123;</span><br><span class="line">                nums[++ slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 &lt;strong&gt;升序排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地&lt;/a&gt;** 删除重复出现的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; ，返回删除后数组的新长度。元素的 &lt;strong&gt;相对顺序&lt;/strong&gt; 应该保持 &lt;strong&gt;一致&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 &lt;code&gt;k&lt;/code&gt; 个元素，那么 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素应该保存最终结果。&lt;/p&gt;
&lt;p&gt;将最终结果插入 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个位置后返回 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;不要使用额外的空间，你必须在 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地 &lt;/a&gt;修改输入数组&lt;/strong&gt; 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判题标准:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统会用下面的代码来测试你的题解:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int[] nums = [...]; // 输入数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int[] expectedNums = [...]; // 长度正确的期望答案&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int k = removeDuplicates(nums); // 调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assert k == expectedNums.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (int i = 0; i &amp;lt; k; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert nums[i] == expectedNums[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果所有断言都通过，那么您的题解将被 &lt;strong&gt;通过&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
