<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只研究僧er</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-18T06:14:32.584Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>刘恒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pdd0515_2</title>
    <link href="http://example.com/2023/05/18/pdd0515-2/"/>
    <id>http://example.com/2023/05/18/pdd0515-2/</id>
    <published>2023-05-18T06:02:24.000Z</published>
    <updated>2023-05-18T06:14:32.584Z</updated>
    
    <content type="html"><![CDATA[<p>多多君在多多农场的某块林地上种了N颗树苗（(编号1~N)，其中第i颗树有健康度Hi。多多君计划给树苗们浇水，每次给某棵树苗浇水可以使其健康度上升A点;同时由于水的流动，其他树苗的健康度都会上升B点(其中A大于等于B)。为了每棵树苗都能够顺利成长，多多君希望所有树苗的健康度都大于或等于M。多多君想知道，在达到这个目标的前提下，最少的浇水次数是多少。</p><p><strong>输入描述</strong></p><p>第一行，4个整数N，M，A和B，分别表示农场中树苗的数量、目标达到的健康度、直接浇水增加的健康度和间接浇水增加的健康度。( 1 &lt;&#x3D; N,M,A,B&lt;&#x3D; 1,000,000，A &gt;&#x3D;B) 接下来N行，每行1个整数Hi，分别表示第i棵树苗初始的健康度Hi。(0&lt;&#x3D; Hi &lt;&#x3D; 1,000,000 )</p><p><strong>输出描述</strong></p><p>共一行，1个整数，表示最少的浇水次数使得所有树苗都能达到目标的健康度。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 10 5 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><h4 id="难度：容易"><a href="#难度：容易" class="headerlink" title="难度：容易"></a>难度：容易</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">根据题目很容易想到，当健康度最小的满足，所有的才会满足</span><br><span class="line"></span><br><span class="line">贪心: 每次给健康度最小的+A, 则其他+B</span><br><span class="line">堆：为了每次O(1)时间获得最小值，需要小根堆</span><br><span class="line">以上做法，首先需要枚举次数O(n), 同时每次需要修改所有的值需要O(n),建立堆O(nlogn),总的时间复杂度O(n^2logn)，一定会超时</span><br><span class="line"></span><br><span class="line">优化：</span><br><span class="line">1. 对于浇水的次数，可以采用二分优化，当mid次可以做到，尝试减小次数；mid次做不到，增大次数</span><br><span class="line">2、容易想到，每次给最小的增加a，其他+b，这个做法是最优解，但是，这样做，需要每次遍历所有元素去添加</span><br><span class="line">   转化：</span><br><span class="line">        给最小的+a,其他的+b，相当于最小+(a - b),再把目标值-b</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// 建立小根堆</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            pq.<span class="built_in">push</span>(h[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> t = m;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 贪心：很容易想到，每次给最小的增加a，其他+b，这个做法是最优解</span></span><br><span class="line"><span class="comment">         但是，这样做，需要每次遍历所有元素去添加</span></span><br><span class="line"><span class="comment">         * 转化：</span></span><br><span class="line"><span class="comment">         给最小的+a,其他的+b，相当于最小+(a - b),再把目标值-b</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; x;i ++) &#123;</span><br><span class="line">            <span class="comment">// 获取最小值</span></span><br><span class="line">            <span class="type">int</span> minval = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">push</span>(minval + a - b);</span><br><span class="line">            t -= b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>() &gt;= t;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分枚举增加次数，最少0次，最多1000000次</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// mid次可以做到，减小次数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(mid)) r = mid;</span><br><span class="line">        <span class="comment">// mid次做不到，增大次数</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Python</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">1000010</span></span><br><span class="line"></span><br><span class="line">s1, s2, s3 = [<span class="number">0</span>] * N, [<span class="number">0</span>] * N, [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000001</span>):</span><br><span class="line">        t = <span class="built_in">str</span>(i)</span><br><span class="line"></span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + <span class="built_in">int</span>(<span class="string">&#x27;5&#x27;</span> <span class="keyword">in</span> t)</span><br><span class="line">        s2[i] = s2[i - <span class="number">1</span>] + <span class="built_in">int</span>(<span class="string">&#x27;20&#x27;</span> <span class="keyword">in</span> t)</span><br><span class="line">        s3[i] = s3[i - <span class="number">1</span>] + <span class="built_in">int</span>(<span class="string">&#x27;520&#x27;</span> <span class="keyword">in</span> t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> T:</span><br><span class="line">        L, R = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(s1[R] - s1[L - <span class="number">1</span>]) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(s2[R] - s2[L - <span class="number">1</span>]) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(s3[R] - s3[L - <span class="number">1</span>]))</span><br><span class="line">        T -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;多多君在多多农场的某块林地上种了N颗树苗（(编号1~N)，其中第i颗树有健康度Hi。多多君计划给树苗们浇水，每次给某棵树苗浇水可以使其健康度上升A点;同时由于水的流动，其他树苗的健康度都会上升B点(其中A大于等于B)。为了每棵树苗都能够顺利成长，多多君希望所有树苗的健康度都大于或等于M。多多君想知道，在达到这个目标的前提下，最少的浇水次数是多少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行，4个整数N，M，A和B，分别表示农场中树苗的数量、目标达到的健康度、直接浇水增加的健康度和间接浇水增加的健康度。( 1 &amp;lt;&amp;#x3D; N,M,A,B&amp;lt;&amp;#x3D; 1,000,000，A &amp;gt;&amp;#x3D;B) 接下来N行，每行1个整数Hi，分别表示第i棵树苗初始的健康度Hi。(0&amp;lt;&amp;#x3D; Hi &amp;lt;&amp;#x3D; 1,000,000 )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共一行，1个整数，表示最少的浇水次数使得所有树苗都能达到目标的健康度。&lt;/p&gt;</summary>
    
    
    
    <category term="笔试题" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="二分" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>pdd0515_1</title>
    <link href="http://example.com/2023/05/17/pdd0520-1/"/>
    <id>http://example.com/2023/05/17/pdd0520-1/</id>
    <published>2023-05-17T04:12:35.000Z</published>
    <updated>2023-05-17T06:16:54.944Z</updated>
    
    <content type="html"><![CDATA[<p>多多君接到了一个给活动商品编号的任务:每次可选的商品编号区间是[L,R]。由于活动的日期定在05月20号，多多君认为包含5，20和520的编号是有特殊含义，准备保留给对应的商品。例如:618520,其中包含了520，是一个特殊编号;而12368就是一个普通编号。多多君想知道，在可选的商品编号区间内，有多少符合上面要求的特殊编号。</p><p><strong>输入描述</strong></p><p>第一行，1个整数T，表示每次可选的编码区间。( 1 &lt;&#x3D;T&lt;&#x3D; 1,000 ) 接下来T行，每行2个整数:L和R，表示编码可选的区间(闭区间，即包括L和R)。( 1&lt;&#x3D;L&lt;&#x3D;R&lt;&#x3D; 1,000,000 )</p><p><strong>输出描述</strong></p><p>共T行，每行3个整数，分别表示对应区间里的5、20和520的编号数量</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 20</span><br><span class="line">100 1000</span><br><span class="line">520 5200</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 1 0</span><br><span class="line">252 19 1</span><br><span class="line">1441 187 6</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><h4 id="难度：容易"><a href="#难度：容易" class="headerlink" title="难度：容易"></a>难度：容易</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">此题要求统计每个区间[L, R]中的符合条件的三种数字的数量</span><br><span class="line">暴力：</span><br><span class="line">最容易想到的做法是第一层循环枚举区间数量，第二层枚举改区间并统计符合的数字，此时时间复杂度为1000 * 1000000，一定会超时</span><br><span class="line">优化：</span><br><span class="line">统计某个区间中的满足某个条件的数字个数，想到前缀和，因此用空间换时间的做法，用前缀和提前统计。</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="type">int</span> s1[N], s2[N], s3[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">1000001</span>;i ++) &#123;</span><br><span class="line">        <span class="comment">// 为了方便判读是否包含某个数字，转为字符串</span></span><br><span class="line">        string t = <span class="built_in">to_string</span>(i);</span><br><span class="line">        </span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + (t.<span class="built_in">find</span>(<span class="string">&quot;5&quot;</span>) != string::npos);</span><br><span class="line">        s2[i] = s2[i - <span class="number">1</span>] + (t.<span class="built_in">find</span>(<span class="string">&quot;20&quot;</span>) != string::npos);</span><br><span class="line">        s3[i] = s3[i - <span class="number">1</span>] + (t.<span class="built_in">find</span>(<span class="string">&quot;520&quot;</span>) != string::npos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="type">int</span> L, R;</span><br><span class="line">        cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">        <span class="comment">// 利用前缀和数组计算数量</span></span><br><span class="line">        cout &lt;&lt; (s1[R] - s1[L - <span class="number">1</span>]) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (s2[R] - s2[L - <span class="number">1</span>]) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (s3[R] - s3[L - <span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Python</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">1000010</span></span><br><span class="line"></span><br><span class="line">s1, s2, s3 = [<span class="number">0</span>] * N, [<span class="number">0</span>] * N, [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000001</span>):</span><br><span class="line">        t = <span class="built_in">str</span>(i)</span><br><span class="line"></span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + <span class="built_in">int</span>(<span class="string">&#x27;5&#x27;</span> <span class="keyword">in</span> t)</span><br><span class="line">        s2[i] = s2[i - <span class="number">1</span>] + <span class="built_in">int</span>(<span class="string">&#x27;20&#x27;</span> <span class="keyword">in</span> t)</span><br><span class="line">        s3[i] = s3[i - <span class="number">1</span>] + <span class="built_in">int</span>(<span class="string">&#x27;520&#x27;</span> <span class="keyword">in</span> t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> T:</span><br><span class="line">        L, R = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(s1[R] - s1[L - <span class="number">1</span>]) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(s2[R] - s2[L - <span class="number">1</span>]) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(s3[R] - s3[L - <span class="number">1</span>]))</span><br><span class="line">        T -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;多多君接到了一个给活动商品编号的任务:每次可选的商品编号区间是[L,R]。由于活动的日期定在05月20号，多多君认为包含5，20和520的编号是有特殊含义，准备保留给对应的商品。例如:618520,其中包含了520，是一个特殊编号;而12368就是一个普通编号。多多君想知道，在可选的商品编号区间内，有多少符合上面要求的特殊编号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行，1个整数T，表示每次可选的编码区间。( 1 &amp;lt;&amp;#x3D;T&amp;lt;&amp;#x3D; 1,000 ) 接下来T行，每行2个整数:L和R，表示编码可选的区间(闭区间，即包括L和R)。( 1&amp;lt;&amp;#x3D;L&amp;lt;&amp;#x3D;R&amp;lt;&amp;#x3D; 1,000,000 )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共T行，每行3个整数，分别表示对应区间里的5、20和520的编号数量&lt;/p&gt;</summary>
    
    
    
    <category term="笔试题" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50</title>
    <link href="http://example.com/2023/03/10/leetcode50/"/>
    <id>http://example.com/2023/03/10/leetcode50/</id>
    <published>2023-03-10T09:26:08.000Z</published>
    <updated>2023-03-10T09:39:53.963Z</updated>
    
    <content type="html"><![CDATA[<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快速幂</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == INT_MIN)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">myPow</span>(<span class="number">1</span> / x, -(n + <span class="number">1</span>)) / x; <span class="comment">// 防止正溢出</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">myPow</span>(<span class="number">1</span> / x, -n); <span class="comment">// 负数冥转化为倒数的正冥</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">myPow</span>(x, n - <span class="number">1</span>) * x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> temp = <span class="built_in">myPow</span>(x, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> temp * temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n) - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现 &lt;a href=&quot;https://www.cplusplus.com/reference/valarray/pow/&quot;&gt;pow(&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;)&lt;/a&gt; ，即计算 &lt;code&gt;x&lt;/code&gt; 的整数 &lt;code&gt;n&lt;/code&gt; 次幂函数（即，&lt;code&gt;xn&lt;/code&gt; ）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode49.字母异位词分组</title>
    <link href="http://example.com/2023/03/10/leetcode49/"/>
    <id>http://example.com/2023/03/10/leetcode49/</id>
    <published>2023-03-10T09:26:01.000Z</published>
    <updated>2023-03-10T09:38:06.639Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计每个字符串的字符数组，相等则为同一类</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; cnt; <span class="comment">// 分类数组</span></span><br><span class="line">        vector&lt;pair&lt;string, string&gt;&gt; f; <span class="comment">// 统计字符数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : strs) &#123;</span><br><span class="line">            <span class="function">string <span class="title">t</span><span class="params">(<span class="string">&#x27;0&#x27;</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i ++)</span><br><span class="line">                t[(s[i] - <span class="string">&#x27;a&#x27;</span>)] = t[(s[i] - <span class="string">&#x27;a&#x27;</span>)] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            f.<span class="built_in">push_back</span>(&#123;s, t&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; f.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            cnt[f[i].second].<span class="built_in">emplace_back</span>(f[i].first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [k, v] : cnt) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个字符串数组，请你将 &lt;strong&gt;字母异位词&lt;/strong&gt; 组合在一起。可以按任意顺序返回结果列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="枚举" scheme="http://example.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode48.旋转图像</title>
    <link href="http://example.com/2023/03/10/leetcode48/"/>
    <id>http://example.com/2023/03/10/leetcode48/</id>
    <published>2023-03-10T09:25:58.000Z</published>
    <updated>2023-03-10T09:35:04.972Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 先转置</span><br><span class="line">- 再按行翻转</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt; n;j ++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : matrix) </span><br><span class="line">            <span class="built_in">reverse</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个 &lt;em&gt;n&lt;/em&gt; × &lt;em&gt;n&lt;/em&gt; 的二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 表示一个图像。请你将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;你必须在**&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地&lt;/a&gt;** 旋转图像，这意味着你需要直接修改输入的二维矩阵。&lt;strong&gt;请不要&lt;/strong&gt; 使用另一个矩阵来旋转图像。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode47.全排列 II</title>
    <link href="http://example.com/2023/03/10/leetcode47/"/>
    <id>http://example.com/2023/03/10/leetcode47/</id>
    <published>2023-03-10T09:25:55.000Z</published>
    <updated>2023-03-10T09:33:36.094Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS：</span><br><span class="line">搜索顺序：按位置从0开始搜索</span><br><span class="line">剪枝：</span><br><span class="line">- st[i]表示字符是否被使用过</span><br><span class="line">- 先排序使相同字符相邻，i &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !st[i - 1]表示如果该字符和前一个相同，同时上一个没有用过则跳过，即把两个字符看成一个整体</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        st.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>(), nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">empty</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !st[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, n, nums);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个可包含重复数字的序列 &lt;code&gt;nums&lt;/code&gt; ，&lt;em&gt;&lt;strong&gt;按任意顺序&lt;/strong&gt;&lt;/em&gt; 返回所有不重复的全排列。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode46.全排列</title>
    <link href="http://example.com/2023/03/10/leetcode46/"/>
    <id>http://example.com/2023/03/10/leetcode46/</id>
    <published>2023-03-10T09:25:52.000Z</published>
    <updated>2023-03-10T09:30:13.546Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS：</span><br><span class="line">搜索顺序：按位置从0开始搜索</span><br><span class="line">剪枝：st[i]表示字符是否被使用过</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        st.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>(), nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">empty</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, n, nums);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其 &lt;em&gt;所有可能的全排列&lt;/em&gt; 。你可以 &lt;strong&gt;按任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leveldb_slice</title>
    <link href="http://example.com/2023/03/10/leveldb-slice/"/>
    <id>http://example.com/2023/03/10/leveldb-slice/</id>
    <published>2023-03-10T08:29:32.000Z</published>
    <updated>2023-03-10T08:41:56.355Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Slice切片。切片是一种简单的数据结构，包含指向数据的指针和数据的大小。</strong></p><p>多个线程可以在没有外部同步的情况下在Slice上调用const方法，但是如果任何线程可以调用非const方法，则访问同一Slice的所有线程都必须使用外部同步。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Dell on 2023/3/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEVELDB_SLICE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEVELDB_SLICE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Slice</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="built_in">Slice</span>() : <span class="built_in">data_</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> <span class="type">char</span>* d, <span class="type">size_t</span> n) : <span class="built_in">data_</span>(d), <span class="built_in">size_</span>(n) &#123;&#125;</span><br><span class="line"><span class="comment">// 通过string构造</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">data_</span>(s.<span class="built_in">data</span>()), <span class="built_in">size_</span>(s.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line"><span class="comment">// 通过char* 构造</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> <span class="type">char</span>* s) : <span class="built_in">data_</span>(s), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(s)) &#123;&#125;</span><br><span class="line"><span class="comment">// 默认的拷贝构造函数和赋值构造函数</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Slice&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 获取数据方法</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"><span class="comment">// 获取数据大小方法</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"><span class="comment">// 判断slice是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">// 清空slice</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        size_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将slice转化为string</span></span><br><span class="line">    <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(data_, size_); &#125;</span><br><span class="line"><span class="comment">// 比较slice的前缀是否为x</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">starts_with</span><span class="params">(<span class="type">const</span> Slice&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((size_ &gt; x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 移除长度为n的前缀</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(n &lt;= size_);</span><br><span class="line">        data_ += n;</span><br><span class="line">        size_ -= n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 比较两个slice</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> Slice&amp; b)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 重载取值运算符</span></span><br><span class="line">    <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(n &lt;= size_);</span><br><span class="line">        <span class="keyword">return</span> data_[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* data_;</span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 重载==运算符</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Slice&amp; x, <span class="type">const</span> Slice&amp; y) &#123;</span><br><span class="line">    <span class="comment">// 两个slice相等：大小相等且数据相等</span></span><br><span class="line">    <span class="built_in">return</span> ((x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">            (<span class="built_in">memcmp</span>(x.<span class="built_in">data</span>(), y.<span class="built_in">data</span>(), x.<span class="built_in">size</span>()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载！=运算符</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Slice&amp; x, <span class="type">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Slice::compare</span><span class="params">(<span class="type">const</span> Slice &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定最小的比较长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len); <span class="comment">// 比较前min_len个数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前min_len个数据相等，长度大的大</span></span><br><span class="line">        <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">            r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LEVELDB_SLICE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define PTR char*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int memcmp(const PTR str1, const PTR str2, size_t count) &#123;</span></span><br><span class="line"><span class="comment">// register 放到寄存器</span></span><br><span class="line"><span class="comment">    register const unsigned char *s1 = (const unsigned char*)str1;</span></span><br><span class="line"><span class="comment">    register const unsigned char *s2 = (const unsigned char*)str2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while (count -- &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">        if (*s1 ++ == *s2 ++)</span></span><br><span class="line"><span class="comment">            return s1[-1] &lt; s2[-1] ? -1 : 1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Slice切片。切片是一种简单的数据结构，包含指向数据的指针和数据的大小。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个线程可以在没有外部同步的情况下在Slice上调用const方法，但是如果任何线程可以调用非const方法，则访问同一Slice的所有线程都必须使用外部同步。&lt;/p&gt;</summary>
    
    
    
    <category term="leveldb源码学习" scheme="http://example.com/categories/leveldb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="leveldb" scheme="http://example.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>leetcode45.跳跃游戏 II</title>
    <link href="http://example.com/2023/03/10/leetcode45/"/>
    <id>http://example.com/2023/03/10/leetcode45/</id>
    <published>2023-03-10T07:11:01.000Z</published>
    <updated>2023-03-10T07:53:04.972Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">通过枚举单纯的动态规划我们可以知道，f[N]数组里面是单调递增的</span><br><span class="line">大概就是0,1,1,2,2,2,....</span><br><span class="line">所以f[i]是一个单调递增的数组</span><br><span class="line">又从动态规划的状态转移方程可知</span><br><span class="line">f[i] = f[j] + 1</span><br><span class="line">我们要枚举i之前的能跳到i的所有j，然后每次找到一个符合条件的j之后就f[i] = f[j]+1</span><br><span class="line">因为初始的时候f[j]都为0，所以不管找到多少个j，都只会使得f[i]在0的基础上加1</span><br><span class="line"></span><br><span class="line">找到第一个能跳到i的j的时候更新了一次f[i]，之后无论再找到多少个j都只能使得f[i] = 0+1 = 1</span><br><span class="line">也就是说除了第一个点之外，后面找到的点都是进行的重复的操作</span><br><span class="line"></span><br><span class="line">所以我们只用找到第一个能跳到i的点j，然后用j去更新i的状态即f[i] = f[j] + 1</span><br><span class="line"></span><br><span class="line">后面更新更多的点同理，只用找到能跳到的第一个点即可</span><br><span class="line"></span><br><span class="line">动态规划时瓶颈就在于更新每个点的最小值时需要遍历所有能跳到i的点，而有了单调性以后就可以用第一个能跳到i的点更新了</span><br><span class="line"></span><br><span class="line">因为找到第一个点和遍历所有的点都只遍历了一次，所以时间复杂度会降到O(n)</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j + nums[j] &lt; i) j ++;</span><br><span class="line">            f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元素 &lt;code&gt;nums[i]&lt;/code&gt; 表示从索引 &lt;code&gt;i&lt;/code&gt; 向前跳转的最大长度。换句话说，如果你在 &lt;code&gt;nums[i]&lt;/code&gt; 处，你可以跳转到任意 &lt;code&gt;nums[i + j]&lt;/code&gt; 处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= j &amp;lt;= nums[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;i + j &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回到达 &lt;code&gt;nums[n - 1]&lt;/code&gt; 的最小跳跃次数。生成的测试用例可以到达 &lt;code&gt;nums[n - 1]&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>leetcode44.通配符匹配</title>
    <link href="http://example.com/2023/03/10/leetcode44/"/>
    <id>http://example.com/2023/03/10/leetcode44/</id>
    <published>2023-03-10T07:10:58.000Z</published>
    <updated>2023-03-10T07:36:14.908Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;?&#x27; 可以匹配任何单个字符。</span><br><span class="line">&#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong><br>$$<br>\<br>题解1：和第十题类似，双字符串匹配问题，可以用动态规划来做。\<br>状态表示：\<br>    dp[i][j]代表s的前i个字符和p的前j个字符是否匹配。\<br>    状态初始化：dp[0][0] &#x3D; true，对于1 &lt;&#x3D; i &lt;&#x3D; m如果p[i - 1] &#x3D; ‘<em>‘ &amp;&amp; dp[0][i - 1]那么dp[0][i] &#x3D; true，这对应着p以</em>*<em>as开头的字符串，因为</em>可以代表0个字符，所以可以往后匹配。\</p><p>状态转移：\<br>    s[i - 1] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; ‘?’，这时候是精准匹配，所以取决于s的前i - 1个字符和p的前j - 1个字符是否匹配。dp[i][j] &#x3D; dp[i - 1][j - 1];\<br>    p[j - 1] &#x3D;&#x3D; ‘<em>‘，这个时候</em>可以代表空串或者任意多个字符。\<br>    如果是空串，那么dp[i][j] &#x3D; dp[i][j - 1]\<br>    如果不是空串，那么dp[i][j] &#x3D; dp[i - 1][j]。这是因为<em>代表了任意多个字符，如果能匹配前i - 1个字符，那么就在</em>代表的字符串后面加上s[i]，就可以匹配前i个字符啦。\<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板题：高精度乘法</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s, p = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    f[i][j] = i &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || i &amp;&amp; f[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/wildcard-matching/">44. 通配符匹配 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个字符串 (&lt;code&gt;s&lt;/code&gt;) 和一个字符模式 (&lt;code&gt;p&lt;/code&gt;) ，实现一个支持 &lt;code&gt;&amp;#39;?&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt; 的通配符匹配。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x27;?&amp;#x27; 可以匹配任何单个字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x27;*&amp;#x27; 可以匹配任意字符串（包括空字符串）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;两个字符串&lt;strong&gt;完全匹配&lt;/strong&gt;才算匹配成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 可能为空，且只包含从 &lt;code&gt;a-z&lt;/code&gt; 的小写字母。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 可能为空，且只包含从 &lt;code&gt;a-z&lt;/code&gt; 的小写字母，以及字符 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode43.字符串相乘</title>
    <link href="http://example.com/2023/03/10/leetcode43/"/>
    <id>http://example.com/2023/03/10/leetcode43/</id>
    <published>2023-03-10T07:10:56.000Z</published>
    <updated>2023-03-10T07:26:32.902Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板题：高精度乘法</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="comment">// 倒着存，方便计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt; m;j ++)</span><br><span class="line">                <span class="comment">// i + j错位相加</span></span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line"><span class="comment">// t为进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>;i &lt; C.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  去除前导0</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !C[k]) k --;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span>) res += C[k --] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定两个以字符串形式表示的非负整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt;，返回 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;不能使用任何内置的 BigInteger 库或直接将输入转换为整数。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="高精度乘法" scheme="http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42.接雨水</title>
    <link href="http://example.com/2023/03/10/leetcode42/"/>
    <id>http://example.com/2023/03/10/leetcode42/</id>
    <published>2023-03-10T07:10:53.000Z</published>
    <updated>2023-03-10T07:21:40.871Z</updated>
    
    <content type="html"><![CDATA[<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单调栈：获取当前位置左右比他大的</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; skt;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!skt.<span class="built_in">empty</span>() &amp;&amp; height[skt.<span class="built_in">top</span>()] &lt; height[i]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = skt.<span class="built_in">top</span>(); <span class="comment">// i 为t右边第一个比他大的</span></span><br><span class="line">                skt.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 此时栈顶为左边第一个比他大的</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (skt.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                res += (i - skt.<span class="built_in">top</span>() - <span class="number">1</span>) * (<span class="built_in">min</span>(height[i], height[skt.<span class="built_in">top</span>()]) - height[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            skt.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="单调栈" scheme="http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode41.缺失的第一个正数</title>
    <link href="http://example.com/2023/03/10/leetcode41/"/>
    <id>http://example.com/2023/03/10/leetcode41/</id>
    <published>2023-03-10T07:10:09.000Z</published>
    <updated>2023-03-10T07:18:57.898Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心思想：把数字放到该放的位置</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">            <span class="keyword">if</span> (x != INT_MIN) x --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; n) &amp;&amp; nums[i] != i &amp;&amp; nums[i] != nums[nums[i]])</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;p&gt;请你实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 并且只使用常数级别额外空间的解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="基数排序" scheme="http://example.com/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode40.组合总和 II</title>
    <link href="http://example.com/2023/03/08/leetcode40/"/>
    <id>http://example.com/2023/03/08/leetcode40/</id>
    <published>2023-03-08T02:22:11.000Z</published>
    <updated>2023-03-08T02:49:32.007Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DFS经典问题---组合</span><br><span class="line">搜索顺序：一个数一个数搜</span><br><span class="line">剪枝：</span><br><span class="line">- (i &gt; u &amp;&amp; candidates[i] == candidates[i - 1]) continue; // 不能包含重复解集</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> u, <span class="type">int</span> target, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u;i &lt; candidates.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; u &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 不能包含重复解集</span></span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i + <span class="number">1</span>, target, sum);  <span class="comment">// 不可以重复使用所以u = i + 1</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个候选人编号的集合 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用 &lt;strong&gt;一次&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;解集不能包含重复的组合。 &lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode39.组合总和</title>
    <link href="http://example.com/2023/03/08/leetcode39/"/>
    <id>http://example.com/2023/03/08/leetcode39/</id>
    <published>2023-03-08T02:22:08.000Z</published>
    <updated>2023-03-08T02:48:37.510Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS经典问题---组合</span><br><span class="line">搜索顺序：一个数一个数搜</span><br><span class="line">剪枝：</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> u, <span class="type">int</span> target, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u;i &lt; candidates.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i, target, sum);  <span class="comment">// 可以重复使用所以u = i</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 &lt;strong&gt;无重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标整数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中可以使数字和为目标数 &lt;code&gt;target&lt;/code&gt; 的 所有 &lt;strong&gt;不同组合&lt;/strong&gt; ，并以列表形式返回。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回这些组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的 &lt;strong&gt;同一个&lt;/strong&gt; 数字可以 &lt;strong&gt;无限制重复被选取&lt;/strong&gt; 。如果至少一个数字的被选数量不同，则两种组合是不同的。 &lt;/p&gt;
&lt;p&gt;对于给定的输入，保证和为 &lt;code&gt;target&lt;/code&gt; 的不同组合数少于 &lt;code&gt;150&lt;/code&gt; 个。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode38.外观数列</title>
    <link href="http://example.com/2023/03/08/leetcode38/"/>
    <id>http://example.com/2023/03/08/leetcode38/</id>
    <published>2023-03-08T02:22:05.000Z</published>
    <updated>2023-03-08T02:37:41.186Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li></ul><p>前五项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure><p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br><span class="line"></span><br><span class="line">输入：n = 4</span><br><span class="line">输出：&quot;1211&quot;</span><br><span class="line">解释：</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = 读 &quot;1&quot; = 一 个 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = 读 &quot;11&quot; = 二 个 1 = &quot;21&quot;</span><br><span class="line">countAndSay(4) = 读 &quot;21&quot; = 一 个 2 + 一 个 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n : 为描述次数</span><br><span class="line">初始为&quot;1&quot;,再描述n - 1次即可</span><br><span class="line">对于每次描述，依靠双指针来实现</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">            <span class="comment">// 描述次数</span></span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">                <span class="type">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == s[j]) k ++; <span class="comment">// 统计相同字符出现次数</span></span><br><span class="line">                t += <span class="built_in">to_string</span>(k - j) + s[j];</span><br><span class="line">                j = k; <span class="comment">//从下一个不同的字符继续</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/count-and-say/">38. 外观数列 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个正整数 &lt;code&gt;n&lt;/code&gt; ，输出外观数列的第 &lt;code&gt;n&lt;/code&gt; 项。&lt;/p&gt;
&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;
&lt;p&gt;你可以将其视作是由递归公式定义的数字字符串序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;countAndSay(1) = &amp;quot;1&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;countAndSay(n)&lt;/code&gt; 是对 &lt;code&gt;countAndSay(n-1)&lt;/code&gt; 的描述，然后转换成另一个数字字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前五项如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.     11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.     21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.     1211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.     111221&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一项是数字 1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &amp;quot;11&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &amp;quot;21&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &amp;quot;1211&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &amp;quot;111221&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要 &lt;strong&gt;描述&lt;/strong&gt; 一个数字字符串，首先要将字符串分割为 &lt;strong&gt;最小&lt;/strong&gt; 数量的组，每个组都由连续的最多 &lt;strong&gt;相同字符&lt;/strong&gt; 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode37.解数独</title>
    <link href="http://example.com/2023/03/08/leetcode37/"/>
    <id>http://example.com/2023/03/08/leetcode37/</id>
    <published>2023-03-08T02:22:02.000Z</published>
    <updated>2023-03-08T02:31:10.216Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p></li></ul><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 搜索顺序： 按行搜索每个单元</span><br><span class="line">- 剪枝条件： 行、列，单元格不重复出现</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> row[<span class="number">9</span>][<span class="number">9</span>], col[<span class="number">9</span>][<span class="number">9</span>], cell[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]; <span class="comment">// 记录行、列和单元格出现的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">9</span>) x ++, y = <span class="number">0</span>; <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 搜索完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="built_in">dfs</span>(board, x, y + <span class="number">1</span>); <span class="comment">//单元为空才搜索</span></span><br><span class="line">        <span class="comment">// 枚举数字，看单元可以填充那个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i]) &#123;</span><br><span class="line">                row[x][i] = col[y][i] = cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                board[x][y] = <span class="string">&#x27;1&#x27;</span> + i;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, x, y + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                row[x][i] = col[y][i] = cell[x / <span class="number">3</span>][y / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">                board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="literal">false</span>, <span class="keyword">sizeof</span> row);</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="literal">false</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">        <span class="built_in">memset</span>(cell, <span class="literal">false</span>, <span class="keyword">sizeof</span> cell);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> t = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i][t] = col[j][t] = cell[i / <span class="number">3</span>][j / <span class="number">3</span>][t] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需 &lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数独部分空格内已填入了数字，空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode36.有效的数独</title>
    <link href="http://example.com/2023/03/08/leetcode36/"/>
    <id>http://example.com/2023/03/08/leetcode36/</id>
    <published>2023-03-08T02:21:56.000Z</published>
    <updated>2023-03-08T02:26:28.295Z</updated>
    
    <content type="html"><![CDATA[<p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>空白格用 <code>&#39;.&#39;</code> 表示。</li></ul><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依次按行、列，单元格枚举</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> st[<span class="number">9</span>];</span><br><span class="line"><span class="comment">// 按行枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> t = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st[t] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 按列枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> t = board[j][i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st[t] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 按单元格枚举</span></span><br><span class="line">        <span class="comment">// 通过左上角坐标枚举单元格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i +=<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>;x &lt; <span class="number">3</span>;x ++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>;y &lt; <span class="number">3</span>;y ++)</span><br><span class="line">                    <span class="keyword">if</span> (board[i + x][j + y] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> t = board[i + x][j + y] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span> (st[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        st[t] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/valid-sudoku/">36. 有效的数独 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;请你判断一个 &lt;code&gt;9 x 9&lt;/code&gt; 的数独是否有效。只需要 &lt;strong&gt;根据以下规则&lt;/strong&gt; ，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;/li&gt;
&lt;li&gt;空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="枚举" scheme="http://example.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode35.搜索插入位置</title>
    <link href="http://example.com/2023/03/07/leetcode35/"/>
    <id>http://example.com/2023/03/07/leetcode35/</id>
    <published>2023-03-07T04:18:21.000Z</published>
    <updated>2023-03-07T04:42:34.701Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分，注意边界</span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target &gt; nums.<span class="built_in">back</span>() ? nums.<span class="built_in">size</span>() : l; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode34.在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://example.com/2023/03/07/leetcode34/"/>
    <id>http://example.com/2023/03/07/leetcode34/</id>
    <published>2023-03-07T04:18:18.000Z</published>
    <updated>2023-03-07T04:43:57.713Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><hr><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><hr><hr><p><strong>分析：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两次二分：</span><br><span class="line">- 从左到右，找右边界</span><br><span class="line">- 从右到左，找左边界 </span><br></pre></td></tr></table></figure><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == target)</span><br><span class="line">            res[<span class="number">1</span>] = l;</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == target)</span><br><span class="line">            res[<span class="number">0</span>] = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target &gt; nums.<span class="built_in">back</span>() ? nums.<span class="built_in">size</span>() : l; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[原题链接](<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（Leetcode）</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
