<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode10.正则表达式匹配</title>
    <url>/2023/02/24/leetcode10/</url>
    <content><![CDATA[<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<p><img src="/./imgs/leetcode10.png" alt="img"></p>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s, p = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= m &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 讨论时*与其前面的字符为一个整体</span></span><br><span class="line">                <span class="keyword">if</span> (i &amp;&amp; p[j] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 平凡转移</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// f[i][j - 2]表示丢弃*及其前面字符</span></span><br><span class="line">                    <span class="comment">// f[i - 1][j]表示利用*</span></span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>] || i &amp;&amp; f[i - <span class="number">1</span>][j] &amp;&amp; (s[i] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/regular-expression-matching/description/">10. 正则表达式匹配 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode1238.循环码排列</title>
    <url>/2023/02/23/leetcode1238/</url>
    <content><![CDATA[<p>给你两个整数 <code>n</code> 和 <code>start</code>。你的任务是返回任意 <code>(0,1,2,,...,2^n-1)</code> 的排列 <code>p</code>，并且满足：</p>
<ul>
<li><code>p[0] = start</code></li>
<li><code>p[i]</code> 和 <code>p[i+1]</code> 的二进制表示形式只有一位不同</li>
<li><code>p[0]</code> 和 <code>p[2^n -1]</code> 的二进制表示形式也只有一位不同</li>
</ul>
<span id="more"></span>



<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, start = 3</span><br><span class="line">输出：[3,2,0,1]</span><br><span class="line">解释：这个排列的二进制表示是 (11,10,00,01)</span><br><span class="line">     所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2]</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格雷码：(0,1,2,,...,2^n-1) 排列为一圈，相邻两项之间只有一位不同</span><br><span class="line">求格雷码：</span><br><span class="line">	1.对称</span><br><span class="line">	2.高位补1，低位补0</span><br><span class="line">题目要求从start开始，因此最后需要和start异或</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">circularPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 求格雷码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line">            <span class="comment">// 对称</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = a.<span class="built_in">size</span>() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j --) </span><br><span class="line">                b.<span class="built_in">push_back</span>(a[j] + (<span class="number">1</span> &lt;&lt; i)); <span class="comment">// 高位补1</span></span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 保证从start开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; x : a) x ^= start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circularPermutation</span><span class="params">(n <span class="type">int</span>, start <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; n;i ++&#123;</span><br><span class="line">        <span class="keyword">var</span> b = a</span><br><span class="line">        <span class="keyword">for</span> j := <span class="built_in">len</span>(a) - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j -- &#123;</span><br><span class="line">            b = <span class="built_in">append</span>(b, a[j] + (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        &#125;</span><br><span class="line">        a = b</span><br><span class="line">    &#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        x ^= start</span><br><span class="line">        a[i] = x</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/description/">1238. 循环码排列 - 力扣（Leetcode）</a>)</p>
<p>[相似题目](<a href="https://leetcode.cn/problems/gray-code/description/">89. 格雷编码 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>格雷码</tag>
        <tag>二进制</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode126.单词接龙Ⅱ</title>
    <url>/2023/02/23/leetcode126/</url>
    <content><![CDATA[<p>按字典 <code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> 这样的单词序列，并满足：</p>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 <code>si</code>（<code>1 &lt;= i &lt;= k</code>）必须是字典 <code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 <code>[beginWord, s1, s2, ..., sk]</code> 的形式返回。</p>
<span id="more"></span>



<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：[[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</span><br><span class="line">解释：存在 2 种最短的转换序列：</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于题目要求没对相邻单词之间仅有单个字母不同，即从当前状态到下一个状态代价为1，同时题目要求最短转化路近，因此问题转化为BFS求最短路问题</span><br><span class="line"></span><br><span class="line">1、首先，利用BFS逆向求出每个单词到endWord的单源最短路径</span><br><span class="line">2、在利用DFS求最短路径，某个单词在要最短路上，距离一定等于最小距离</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len, min_dis;</span><br><span class="line">    unordered_set&lt;string&gt; seen; <span class="comment">// 合理的单词</span></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; d; <span class="comment">//距离</span></span><br><span class="line">    string ed;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res; <span class="comment">// 所有路径</span></span><br><span class="line">    vector&lt;string&gt; p; <span class="comment">// 单个路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(ed);</span><br><span class="line">        d[ed] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++) &#123;</span><br><span class="line">                string v = u;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;ch &lt;= <span class="string">&#x27;z&#x27;</span>;ch ++) &#123;</span><br><span class="line">                    v[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (seen.<span class="built_in">find</span>(v) == seen.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d.<span class="built_in">find</span>(v) == d.<span class="built_in">end</span>()) d[v] = d[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; u)</span> </span>&#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (u == ed) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p);</span><br><span class="line">            p.<span class="built_in">pop_back</span>(); <span class="comment">// 求取多个路径</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++) &#123;</span><br><span class="line">            string v = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;ch &lt;= <span class="string">&#x27;z&#x27;</span>;ch ++) &#123;</span><br><span class="line">                v[i] = ch;</span><br><span class="line">                <span class="keyword">if</span> (seen.<span class="built_in">find</span>(v) == seen.<span class="built_in">end</span>() || d.<span class="built_in">find</span>(v) == d.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p.<span class="built_in">size</span>() + d[v] == min_dis)</span><br><span class="line">                    <span class="built_in">dfs</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        len = beginWord.<span class="built_in">size</span>();</span><br><span class="line">        seen = <span class="built_in">unordered_set</span>&lt;string&gt;(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (seen.<span class="built_in">find</span>(endWord) == seen.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        seen.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">        ed = endWord;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        min_dis = d[beginWord];</span><br><span class="line">        <span class="built_in">dfs</span>(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/word-ladder-ii/description/">126. 单词接龙 II - 力扣（Leetcode）</a>)</p>
<p>[相似题目](<a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode1140.石子游戏II</title>
    <url>/2023/02/22/leetcode1140/</url>
    <content><![CDATA[<p>爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 <strong>排成一行</strong>，每堆都有正整数颗石子 <code>piles[i]</code>。游戏以谁手中的石子最多来决出胜负。</p>
<p>爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，<code>M = 1</code>。</p>
<p>在每个玩家的回合中，该玩家可以拿走剩下的 <strong>前</strong> <code>X</code> 堆的所有石子，其中 <code>1 &lt;= X &lt;= 2M</code>。然后，令 <code>M = max(M, X)</code>。</p>
<p>游戏一直持续到所有石子都被拿走。</p>
<p>假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。</p>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：piles = [2,7,9,4,4]</span><br><span class="line">输出：10</span><br><span class="line">解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">状态表示：</span><br><span class="line">	f[i, j]表示当石子为i~n，M=j时Alice可以得到的最大数量</span><br><span class="line">状态转移：</span><br><span class="line">	f[i][j] = max(f[i][j], s[n] - s[i - 1] - f[i + k][max(k, j)])</span><br><span class="line">	f[i + k][max(k, j)] 表示Bob可以获得的石子， s[n] - s[i - 1] - f[i + k][max(k, j)]表示Alice可以获得的石子</span><br><span class="line">	s[n] - s[i - 1]前缀和优化，表示i~n的石子数量</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">stoneGameII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + piles[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i;i --)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;i + k - <span class="number">1</span> &lt;= n &amp;&amp; k &lt;= <span class="number">2</span> * j;k ++)</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], s[n] - s[i - <span class="number">1</span>] - f[i + k][<span class="built_in">max</span>(k, j)]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stoneGameII</span><span class="params">(piles []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span> = <span class="built_in">len</span>(piles)</span><br><span class="line">    <span class="keyword">var</span> f  [<span class="number">105</span>][<span class="number">105</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> s [<span class="number">105</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt;= n;i += <span class="number">1</span> &#123;</span><br><span class="line">        s[i] = piles[i - <span class="number">1</span>] + s[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n;i &gt; <span class="number">0</span>;i -- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>;j &lt;= n;j ++ &#123;</span><br><span class="line">            <span class="keyword">for</span> k := <span class="number">1</span>;i + k - <span class="number">1</span> &lt;= n &amp;&amp; k &lt;= <span class="number">2</span> * j;k ++ &#123;</span><br><span class="line">                f[i][j] = Max(f[i][j], s[n] - s[i - <span class="number">1</span>] - f[i + k][Max(k, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>[原题链接](<a href="https://leetcode.cn/problems/stone-game-ii/description/">1140. 石子游戏 II - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode127.单词接龙</title>
    <url>/2023/02/23/leetcode127/</url>
    <content><![CDATA[<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
<span id="more"></span>



<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于题目要求没对相邻单词之间仅有单个字母不同，即从当前状态到下一个状态代价为1，同时题目要求最短转化路近，因此问题转化为BFS求最短路问题</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<blockquote>
<ul>
<li><h3 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h3></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len, min_dis;</span><br><span class="line">    unordered_set&lt;string&gt; seen;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; d;</span><br><span class="line">    string ed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(ed);</span><br><span class="line">        d[ed] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++) &#123;</span><br><span class="line">                string v = u;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;ch &lt;= <span class="string">&#x27;z&#x27;</span>;ch ++) &#123;</span><br><span class="line">                    v[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (seen.<span class="built_in">find</span>(v) == seen.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d.<span class="built_in">find</span>(v) == d.<span class="built_in">end</span>()) d[v] = d[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        len = beginWord.<span class="built_in">size</span>();</span><br><span class="line">        seen = <span class="built_in">unordered_set</span>&lt;string&gt;(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (seen.<span class="built_in">find</span>(endWord) == seen.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        seen.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">        ed = endWord;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d[beginWord];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><h4 id="正向搜索"><a href="#正向搜索" class="headerlink" title="正向搜索"></a>正向搜索</h4></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len, min_dis;</span><br><span class="line">    unordered_set&lt;string&gt; seen;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; d;</span><br><span class="line">    string ed;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        d[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i ++) &#123;</span><br><span class="line">                string v = u;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;ch &lt;= <span class="string">&#x27;z&#x27;</span>;ch ++) &#123;</span><br><span class="line">                    v[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (seen.<span class="built_in">find</span>(v) == seen.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d.<span class="built_in">find</span>(v) == d.<span class="built_in">end</span>()) d[v] = d[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">                    <span class="keyword">if</span> (v == ed) <span class="keyword">return</span> d[v];</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        len = beginWord.<span class="built_in">size</span>();</span><br><span class="line">        seen = <span class="built_in">unordered_set</span>&lt;string&gt;(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (seen.<span class="built_in">find</span>(endWord) == seen.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        seen.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">        ed = endWord;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(beginWord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>[原题链接](<a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙 - 力扣（Leetcode）</a>)</p>
<p>[相似题目](<a href="https://leetcode.cn/problems/word-ladder-ii/description/">126. 单词接龙 II - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>单源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode1326.灌溉花园的最少水龙头数目</title>
    <url>/2023/02/21/leetcode1326/</url>
    <content><![CDATA[<p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i - ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, ranges = [3,4,1,1,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">点 0 处的水龙头可以灌溉区间 [-3,3]</span><br><span class="line">点 1 处的水龙头可以灌溉区间 [-3,5]</span><br><span class="line">点 2 处的水龙头可以灌溉区间 [1,3]</span><br><span class="line">点 3 处的水龙头可以灌溉区间 [2,4]</span><br><span class="line">点 4 处的水龙头可以灌溉区间 [4,4]</span><br><span class="line">点 5 处的水龙头可以灌溉区间 [5,5]</span><br><span class="line">只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于花园的长度为n，可以将问题转化为选择最少的水龙头覆盖整个区间</span><br><span class="line">做法：</span><br><span class="line">	按照左端点排序，假设当前覆盖到的区间右端点为ed，只需要满足选择的子区间的左端点小于ed同时尽可能使ed变的更大</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTaps</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">r</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">            r[i] = <span class="built_in">make_pair</span>(<span class="built_in">max</span>(<span class="number">0</span>, i - ranges[i]), <span class="built_in">min</span>(ranges[i] + i, n));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n &amp;&amp; ed &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> next_ed = <span class="number">0</span>; <span class="comment">// 下一次的覆盖末端点</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= n &amp;&amp; r[i].first &lt;= ed) &#123;</span><br><span class="line">                next_ed = <span class="built_in">max</span>(next_ed, r[i].second);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ed == next_ed) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 当ed == nexted 时无法在选择新区间</span></span><br><span class="line"></span><br><span class="line">            res ++;</span><br><span class="line">            ed = next_ed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/">1326. 灌溉花园的最少水龙头数目 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode2357.使数组中所有元素都等于零</title>
    <url>/2023/02/24/leetcode2357/</url>
    <content><![CDATA[<p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>
<ul>
<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li>
<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li>
</ul>
<p>返回使 <code>nums</code> 中所有元素都等于 <code>0</code> 需要的 <strong>最少</strong> 操作数。</p>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,0,3,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。</span><br><span class="line">第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。</span><br><span class="line">第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单思维题，只需要考虑不重复的非0元素的个数</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums)</span><br><span class="line">            <span class="keyword">if</span> (num)</span><br><span class="line">                seen.<span class="built_in">insert</span>(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> seen.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/description/">2357. 使数组中所有元素都等于零 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode84.柱状图中最大矩形</title>
    <url>/2023/02/23/leetcode84/</url>
    <content><![CDATA[<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要求最大矩形的面积，考虑当前位置i所构成的最大矩形，只需要考虑前后最接近它且高度小于它的位置，显然，只需要维护两个单调栈即可</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<blockquote>
<ul>
<li>借助STL</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[stk.<span class="built_in">top</span>()] &gt;= h[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) left[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j --) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[stk.<span class="built_in">top</span>()] &gt;= h[j]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) right[j] = n;</span><br><span class="line">            <span class="keyword">else</span> right[j] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, h[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>数组模拟</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l[N], r[N], q[N];</span><br><span class="line">        <span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">-1</span>);</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt;= heights[q[tt]]) tt --;</span><br><span class="line">            l[i] = q[tt];</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i --) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt;= heights[q[tt]]) tt --;</span><br><span class="line">            r[i] = q[tt];</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) </span><br><span class="line">            res = <span class="built_in">max</span>(res, (r[i] - l[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（Leetcode）</a>)</p>
<p>[相似题目](<a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/description/">2357. 使数组中所有元素都等于零 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode85.最大矩形</title>
    <url>/2023/02/24/leetcode85/</url>
    <content><![CDATA[<p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、枚举矩形的边界，从边界出发统计连续1的个数，之后转化为求柱状图中的最大矩形</span><br><span class="line">2、单调栈求最大面积</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longHeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[stk.<span class="built_in">top</span>()] &gt;= h[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) left[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j --) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[stk.<span class="built_in">top</span>()] &gt;= h[j]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) right[j] = n;</span><br><span class="line">            <span class="keyword">else</span> right[j] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, h[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++)</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i) f[i][j] = f[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> f[i][j] = <span class="number">1</span>; <span class="comment">// 边界0</span></span><br><span class="line">                &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">longHeight</span>(f[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[原题链接](<a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形 - 力扣（Leetcode）</a>)</p>
<p>[相似题目](<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode98.二叉搜索树</title>
    <url>/2023/02/23/leetcode98/</url>
    <content><![CDATA[<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<span id="more"></span>

<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只需要保证左子树的最大值小于root,右子树的最小值大于root </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> max_value, min_value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, max_value, min_value);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 借助引用实现自下而上传递</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; max_value, <span class="type">int</span>&amp; min_value)</span> </span>&#123;</span><br><span class="line">        min_value = max_value = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="type">int</span> now_max, now_min;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(root-&gt;left, now_max, now_min))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (now_max &gt;= root-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, now_max);</span><br><span class="line">            min_value = <span class="built_in">min</span>(min_value, now_min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="type">int</span> now_max, now_min;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(root-&gt;right, now_max, now_min))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (now_min &lt;= root-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, now_max);</span><br><span class="line">            min_value = <span class="built_in">min</span>(min_value, now_min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode, min_value, max_value <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.Val &lt;= min_value || max_value &lt;= root.Val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root.Left, min_value, root.Val) &amp;&amp; dfs(root.Right, root.Val, max_value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>[原题链接](<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（Leetcode）</a>)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
